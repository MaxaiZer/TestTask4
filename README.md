
# TestTask 4
## ТЗ

### Часть 1. Балансировщик нагрузки
**Основной функционал:**
- Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080).
- При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения.
- Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

**Распределение запросов:**
- Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
- Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы).

**Параллелизм и конкурентность:**
- Обеспечить одновременную обработку нескольких запросов с использованием горутин.
- Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

**Обработка ошибок:**
- Реализовать обработку ошибок при обращении к бэкендам.
- Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

**Логирование:**
- Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

**Конфигурация:**
- Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки.
- Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

### Часть 2. Реализация Rate-Limiting
Требуется разработать модуль для ограничения частоты запросов (rate-limiting) на основе алгоритма Token Bucket. Модуль должен защищать внутренние сервисы от перегрузок, обеспечивать честное распределение ресурсов между клиентами и корректно обрабатывать высокую нагрузку.

**Функциональные требования:**

**Реализация алгоритма Token Bucket:**
- Каждому клиенту (IP или API-ключ) выделяется отдельный **bucket** токенов.
- Настройки bucket: количество токенов (емкость), скорость пополнения.
- Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.

**Гранулярное ограничение:**
- Отслеживать состояние каждого клиента (IP/API-ключ)
- Поддерживать возможность настройки разных лимитов для разных клиентов.
- Настройки для разных клиентов можно сохранять в базе данных

**Автоматическое пополнение токенов:**
- Использовать `time.Ticker` для периодического пополнения токенов в buckets.
- Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).

**Конкурентность:**
- Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
- Обеспечить минимальные блокировки для максимизации производительности.

Требуется подготовить README с описанием сборки и запуска проекта.

## Запуск

- ```make build```/```make run``` - сборка/запуск балансировщика
- ```make test``` - тесты
- ```make k6``` - нагрузочное тестирование с помощью k6 (но если и балансировщик и серверы подняты в докере, то заметное время будет тратиться на DNS resolving)
- ```docker compose up --build``` - балансировщик + два сервера. Можно делать запросы на localhost:8080 либо localhost:8080/sleep?delay=N, чтобы сервер ждал N секунд перед ответом (для тестирования алгоритма least connections)

Конфиг
- по умолчанию ищется в configs/config.yaml, если не задана переменная окружения CONFIG_PATH
- доступные алгоритмы: round-robin и least-connections
- health checks для серверов обязательны

## Итог
Выполнена 1 часть + доп. алгоритм распределения + health checks
